This is great coverage. You’re ~90% there. To close the loop on the “callee hung up” and make your RTB stack rock-solid, here are the precise changes I’d ship next—mapped to your files and the gaps you flagged.

1) Prefer SIP when provided (fix your <Dial>)
File: server/twilio-webhooks.ts (around lines 254–256)
Goal: if bidder returns a SIP URI, dial via <Sip>; otherwise <Number>.

ts
Copy
Edit
// add near top or a utils file
const isSip = (dest: string) => /^sip:/i.test(dest) || /@/.test(dest);
const toE164 = (n: string) => {
  if (!n) return null;
  let s = n.trim().replace(/[^\d+]/g, "");
  if (!s.startsWith("+")) s = "+" + s; // assume already has country code from bidders
  return /^\+[1-9]\d{7,14}$/.test(s) ? s : null;
};

// ...inside your handler where you build TwiML:
const dest = winner.destinationNumber?.trim();
let dialXml: string;

if (isSip(dest)) {
  const sipUri = dest.startsWith("sip:") ? dest : `sip:${dest}`;
  dialXml = `
    <Dial answerOnBridge="true" timeout="30" callerId="${callerIdToPresent}">
      <Sip>${sipUri}</Sip>
    </Dial>`;
} else {
  const e164 = toE164(dest);
  if (!e164) {
    // short-circuit: never return broken TwiML
    return res.type("text/xml").send(`<Response><Say>All buyers unavailable. Please try again later.</Say></Response>`);
  }
  dialXml = `
    <Dial answerOnBridge="true" timeout="30" callerId="${callerIdToPresent}">
      <Number>${e164}</Number>
    </Dial>`;
}

res.type("text/xml").send(`<?xml version="1.0" encoding="UTF-8"?><Response>${dialXml}</Response>`);
Why: Every Ringba/Telnyx buyer is happier on SIP. This also fixes the case where a DID answers then their app errors because headers/tokens are missing.

2) Per-buyer Caller ID policy (fix ANI rejections)
Schema: add to rtb_targets (or companion table):

callerIdPolicy enum: passthrough | fixed | campaign_default

callerIdFixed varchar (E.164)

forceE164 boolean (default true)

File: server/twilio-webhooks.ts and wherever you compute callerIdToPresent:

ts
Copy
Edit
function chooseCallerId(inboundAni: string, targetCfg: TargetCfg, campaignCfg: CampaignCfg) {
  const toE164 = (n: string) => { /* same as above */ };

  if (targetCfg.callerIdPolicy === "fixed" && targetCfg.callerIdFixed) {
    const fixed = toE164(targetCfg.callerIdFixed);
    if (fixed) return fixed;
  }
  if (targetCfg.callerIdPolicy === "passthrough") {
    const ani = toE164(inboundAni);
    if (ani) return ani;
  }
  // fallback to campaign default or first Twilio number you own
  const fallback = toE164(campaignCfg.defaultCallerId || process.env.DEFAULT_CALLER_ID!);
  return fallback || "+10000000000"; // never leave it blank
}
Why: Many buyers only accept a whitelisted ANI or require a domestic caller ID. This kills the “callee hung up” right after 200 OK.

3) Validate and normalize destination (no more malformed <Number>)
File: server/rtb-service.ts (lines 1076–1095)

Augment your validation:

ts
Copy
Edit
const dest = parsed.destinationNumber;
if (isSip(dest)) {
  parsed.destinationNumber = dest.startsWith("sip:") ? dest : `sip:${dest}`;
} else {
  const e164 = toE164(dest);
  if (!e164) {
    return reject({ reason: "invalid_destination", details: dest });
  }
  parsed.destinationNumber = e164;
}
Why: Prevents TwiML runtime faults and subtle carrier rejections.

4) Add optional HMAC auth (so serious buyers can verify you)
Config: authMethod: 'hmac-sha256', authSecret
Outbound header: X-RTB-Signature: base64(hmacSHA256(body, secret)) + X-RTB-Timestamp

File: server/rtb-service.ts (where you send pings)

ts
Copy
Edit
if (target.authMethod === "hmac-sha256") {
  const timestamp = Date.now().toString();
  const bodyStr = JSON.stringify(payload);
  const sig = crypto.createHmac("sha256", target.authSecret).update(timestamp + "." + bodyStr).digest("base64");
  headers["X-RTB-Timestamp"] = timestamp;
  headers["X-RTB-Signature"] = sig;
}
Why: Gives you production-grade auth without IP allowlisting.

5) Early hang-up auto-retry (optional but very useful)
If B-leg ends with callee hang-up within N seconds (e.g., <5s), optionally route to next eligible bidder.

File: server/twilio-webhooks.ts status callback handler

Record bridgeStartAt

On completed with duration < 5 and hangupBy === 'callee', trigger a single retry to the next ranked bid that’s still within expiresIn (if you store it).

Why: Saves live traffic if a buyer’s app answers then rejects.

6) Add SIP headers / DTMF token per buyer (if they need matching)
Schema additions per target:

sipHeaders (JSON map, e.g., { "X-Call-Id": "{requestId}" })

dtmfOnAnswer (string, e.g., 123#)

File: twilio-webhooks.ts (SIP branch)

xml
Copy
Edit
<Sip>sip:dest@buyer.sip;
  $${Object.entries(target.sipHeaders||{}).map(([k,v]) => `${k}=${encodeURIComponent(resolveTokens(v))}`).join(";")}
</Sip>
On connect DTMF: use <Play digits="ww123#"/> in a <Gather> or Dial’s answerOnBridge="true" + <Say>/<Play> right after connection (advanced: Twilio’s <SendDigits> on <Number>).

Why: Some Ringba buyers require a token/header to tie the call to bid.

7) Tiny RTB simulator + unit tests (you marked missing)
Add a dev route: POST /_sim/rtb that returns canned responses (accept true/false, SIP vs DID, invalid number).
Unit tests:

parsing happy path (SIP and DID)

invalid destination → rejected

callerIdPolicy fixed vs passthrough

HMAC header present/valid

This gives you repeatable coverage and a playground for buyers.

8) Operator checklist (use today to debug a buyer)
In your winner log, verify you got a sipAddress.

Re-run the same call forcing SIP route.

If still failing, set buyer’s callerIdPolicy = fixed with a domestic E.164 you own and retry.

If it works with fixed ANI but not passthrough → it’s an ANI policy.

If it works with SIP but not DID → keep SIP for that buyer.

Ask buyer if they need a SIP header / DTMF token; add via per-target config.

If you want, paste the snippet around twilio-webhooks.ts:254–256 and I’ll return an exact diff you can drop in. Also happy to draft the SQL migration for the per-target caller-ID / SIP headers fields.